<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas View</title>
  <style>
    :root {
      --bg: #0f172a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #6366f1;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1000px 600px at 10% -10%, #1f2937 0%, var(--bg) 50%, var(--bg) 100%);
      color: var(--text);
    }
    .app {
      display: flex;
      align-items: flex-start;
      gap: 24px;
      padding: 16px 16px 16px 8px; /* reduce left padding */
      width: 100%;
      margin: 0; /* remove centering */
      box-sizing: border-box;
      min-height: 100vh;
    }
    .sidebar {
      width: 280px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.16);
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
      /* Top alignment with canvas handled dynamically via JS */
      position: relative;
      z-index: 1; /* ensure above stage/canvas if overlapping */
      align-self: center; /* keep sidebar vertically centered on page */
      margin-left: 32px; /* left offset */
    }
    .sidebar .panel-title {
      margin: 0 0 12px;
      font-size: 18px;
      color: var(--text);
    }
    .control-group { margin-bottom: 12px; }
    .control-group label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .control-group input[type="range"],
    .control-group input[type="number"],
    .control-group select { width: 100%; }
    /* Panel container */
    .panel {
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 12px;
    }
    .panel + .panel { margin-top: 12px; }
    .content-images { display: flex; flex-direction: column; gap: 8px; }
    .content-images [data-asset-type] {
      display: block; border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
      cursor: grab; user-select: none; transition: border-color 120ms ease, box-shadow 120ms ease, transform 120ms ease;
    }
    .content-images img[data-asset-type="image"] {
      width: 100%; height: auto; display: block; border-radius: 8px;
    }
    .content-images .content-text[data-asset-type="text"] {
      padding: 12px; background: rgba(255,255,255,0.06); color: var(--text);
      font: 600 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    .content-images .content-video[data-asset-type="video"] video { width: 100%; height: auto; display: block; border-radius: 8px; }
    /* Disable native browser drag ghost for images/videos */
    .content-images img, .content-images video { -webkit-user-drag: none; user-select: none; }
    .content-images [data-asset-type]:hover {
      border-color: rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.26) inset, 0 8px 24px rgba(0,0,0,0.3);
      transform: translateY(-1px);
    }
    .content-images [data-asset-type]:active { cursor: grabbing; }
    body.is-dragging-asset { cursor: grabbing !important; }
    canvas.drag-target { outline: 2px dashed rgba(255,255,255,0.35); outline-offset: 4px; }
    /* Top controls above the canvas */
    #top-controls {
      display: flex;
      justify-content: center;
      width: auto;
      position: fixed;
      top: 48px; /* requested offset from top */
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      margin-bottom: 0; /* fixed elements don't affect layout flow */
    }
    #canvas-size-group {
      display: flex;
      flex-direction: row;
      gap: 8px;
    }
    #canvas-size-group button { justify-content: center; }
    /* Floating grid toggle under canvas */
    #grid-toggle-floating { position: fixed; z-index: 3; }
    .icon-btn { 
      appearance: none; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06);
      color: var(--text); padding: 8px; border-radius: 8px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;
      transition: background 120ms ease, border-color 120ms ease, filter 120ms ease;
    }
    .icon-btn svg { width: 18px; height: 18px; display: block; fill: rgba(255,255,255,0.7); }
    .icon-btn:hover { background: rgba(255,255,255,0.12); }
    .icon-btn.active { background: var(--accent); border-color: rgba(255,255,255,0.22); }
    .icon-btn.active svg { fill: white; }
    .btn[disabled], .icon-btn[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* Text overlay */
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 50; }
    .overlay.show { display: flex; }
    .modal { width: min(560px, 90vw); background: rgba(17,24,39,0.95); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 16px; box-shadow: 0 20px 50px rgba(0,0,0,0.45); }
    .modal h3 { margin: 0 0 12px; color: var(--text); font-size: 16px; }
    .modal .row { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; }
    .modal .field { display: flex; gap: 8px; }
    .modal input[type="text"] { flex: 1; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.06); color: var(--text); font: inherit; }
    .modal .actions { margin-top: 12px; display: flex; gap: 8px; justify-content: flex-end; }
    /* In-canvas text editor */
    #canvas-text-editor {
      position: fixed;
      z-index: 10;
      background: transparent;
      color: #111827;
      border: 1px dashed rgba(79,70,229,0.6);
      border-radius: 6px;
      padding: 2px 4px;
      outline: none;
      resize: none;
      overflow: hidden;
      white-space: pre-wrap;
    }
    .btn {
      appearance: none;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font: inherit;
      text-align: center;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease, filter 120ms ease;
    }
    .btn:hover { background: rgba(255, 255, 255, 0.12); }
    .btn:focus { outline: 2px solid rgba(255, 255, 255, 0.3); outline-offset: 2px; }
    .btn-primary { background: var(--accent); border-color: rgba(255, 255, 255, 0.22); color: white; box-shadow: 0 6px 20px rgba(0,0,0,0.25); }
    .btn-primary:hover { filter: brightness(1.05); }
    .stage {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column; /* stack toolbar above canvas */
      align-items: center; /* center horizontally */
      justify-content: center; /* center stack vertically */
      height: calc(100vh - 32px); /* account for .app vertical padding (16px top + 16px bottom) */
      position: relative;
      z-index: 0;
    }
    canvas {
      background: #ffffff; /* default white background */
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      display: block;
      /* Width/height are set dynamically via JS to enforce fixed aspect ratios */
    }
    @media (max-width: 800px) {
      .app { flex-direction: column; align-items: stretch; }
      .sidebar { width: 100%; }
      canvas { height: 60vh; }
    }
  </style>
  
</head>
<body>
  <div class="app">
    <aside class="sidebar" aria-label="Controls sidebar">
      <div class="panel" style="width:100%">
        <div class="control-group">
          <h3 class="panel-title">Content</h3>
          <div class="content-images">
            <button id="open-add-text" class="btn" aria-haspopup="dialog">Add text</button>
            <button id="open-generate-text" class="btn" aria-haspopup="dialog">Generate text</button>
            <img data-asset-type="image" src="https://picsum.photos/seed/cursor1/480/320" alt="Sample image" loading="lazy"/>
            <div class="content-video" data-asset-type="video" data-src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4">
              <video muted playsinline loop src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"></video>
            </div>
          </div>
        </div>
      </div>
    </aside>
    <div class="stage">
      <div id="top-controls">
        <div id="canvas-size-group" aria-label="Canvas size">
          <button class="btn btn-primary" value="landscape" data-selected="true" aria-pressed="true">Landscape</button>
          <button class="btn" value="square" aria-pressed="false">Square</button>
          <button class="btn" value="portrait" aria-pressed="false">Portrait</button>
        </div>
      </div>
      <canvas id="main-canvas" class="size-landscape" aria-label="Main canvas occupying most of the page"></canvas>
      <!-- floating toggle placed after canvas; scripted to bottom-left of canvas -->
      <div id="grid-toggle-floating">
        <button id="toggle-grid-btn" class="icon-btn" aria-label="Toggle grid" aria-pressed="false">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 3h8v8H3V3zm10 0h8v8h-8V3zM3 13h8v8H3v-8zm10 0h8v8h-8v-8z"/></svg>
        </button>
      </div>
      <textarea id="canvas-text-editor" style="display:none" spellcheck="false"></textarea>
      <!-- Add Text overlay -->
      <div id="add-text-overlay" class="overlay" role="dialog" aria-modal="true" aria-labelledby="add-text-title">
        <div class="modal">
          <h3 id="add-text-title">Add text to canvas</h3>
          <div class="row">
            <input id="add-text-input" type="text" placeholder="Type your text..." />
          </div>
          <div class="row">
            <input id="generate-text-input" type="text" placeholder="Describe what to generate (prompt)..." />
          </div>
          <div class="actions">
            <button id="add-text-cancel" class="btn">Cancel</button>
            <button id="generate-text" class="btn" disabled>Generate</button>
            <button id="add-text-confirm" class="btn btn-primary" disabled>Add</button>
          </div>
          <div id="generate-preview" style="margin-top:8px;color:var(--text);white-space:pre-wrap"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    (function () {
      const canvas = document.getElementById('main-canvas');
      const sizeGroup = document.getElementById('canvas-size-group');
      /**
       * Asset model stored in CSS pixel coordinates relative to the canvas.
       * type: 'image' | 'text' | 'video'
       * For images/videos: x, y, width, height, element
       * For text: x, y, text, color, font, maxWidth (optional)
       */
      const assets = [];
      const interactionState = {
        hoveredAssetIndex: -1,
        selectedAssetIndices: new Set(),
        isMovingSelected: false,
        lastMoveClientX: 0,
        lastMoveClientY: 0,
        // Marquee selection
        isMarqueeSelecting: false,
        marqueeStartCX: 0,
        marqueeStartCY: 0,
        marqueeEndCX: 0,
        marqueeEndCY: 0,
        marqueeAdditive: false,
        // Resize handles
        hoveredHandle: null, // 'nw'|'ne'|'se'|'sw'|null
        isResizingSelected: false,
        activeHandle: null,
        resizeStartClientX: 0,
        resizeStartClientY: 0,
        initialSelectionBounds: null,
        initialSelectedSnapshot: null, // [{index,x,y,width,height,font}]
      };
      let lastGeometry = null; // { width, height, cols, rows, colWidth, rowHeight, verticals[], horizontals[] }
      // Offscreen grid cache to avoid re-drawing the grid every frame
      let gridCacheCanvas = null;
      let gridCacheCtx = null;
      let gridCacheBitmap = null;
      let lastCacheSignature = '';
      let isGridEnabled = false;
      // Redraw scheduler
      let redrawScheduled = false;
      function scheduleRedraw() {
        if (redrawScheduled) return;
        redrawScheduled = true;
        requestAnimationFrame(() => {
          redrawScheduled = false;
          redraw();
        });
      }

      function getResponsiveColumns(canvasWidth) {
        if (canvasWidth < 600) return 4;      // mobile
        if (canvasWidth < 1024) return 8;     // tablet
        return 12;                             // desktop and up
      }

      function getCanvasDimensions() {
        if (lastGeometry) return { width: lastGeometry.width, height: lastGeometry.height };
        const rect = canvas.getBoundingClientRect();
        return { width: Math.max(1, Math.round(rect.width)), height: Math.max(1, Math.round(rect.height)) };
      }

      function clamp(value, min, max) { return Math.min(max, Math.max(min, value)); }

      function fitRectToCanvas(width, height) {
        const { width: cw, height: ch } = getCanvasDimensions();
        let w = width, h = height;
        if (w > cw || h > ch) {
          const s = Math.min(cw / w, ch / h);
          w = Math.max(1, Math.round(w * s));
          h = Math.max(1, Math.round(h * s));
        }
        return { width: w, height: h };
      }

      function clampAssetWithinCanvas(asset) {
        const { width: cw, height: ch } = getCanvasDimensions();
        if (asset.type !== 'text') {
          asset.x = clamp(asset.x, 0, cw - asset.width);
          asset.y = clamp(asset.y, 0, ch - asset.height);
        } else {
          const maxW = asset.maxWidth || cw - 16;
          asset.x = clamp(asset.x, 0, Math.max(0, cw - maxW));
          // allow baseline inside canvas
          const px = parseFontPx(asset.font) || 16;
          const lineHeight = Math.round(px * 1.2);
          asset.y = clamp(asset.y, lineHeight, ch - 4);
        }
      }

      function getResponsiveRows(canvasWidth, canvasHeight, cols) {
        // Keep rows ~= cols to mimic canvas aspect ratio, but enforce minimum row height
        const maxRowsByHeight = Math.max(1, Math.floor(canvasHeight / 130));
        return Math.max(1, Math.min(Math.round(cols), maxRowsByHeight));
      }

      function resizeCanvasAndDraw() {
        const devicePixelRatioValue = Math.min(2, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();

        const cssWidth = Math.max(1, Math.round(rect.width));
        const cssHeight = Math.max(1, Math.round(rect.height));

        canvas.width = Math.max(1, Math.floor(cssWidth * devicePixelRatioValue));
        canvas.height = Math.max(1, Math.floor(cssHeight * devicePixelRatioValue));

        const context = canvas.getContext('2d');
        context.setTransform(devicePixelRatioValue, 0, 0, devicePixelRatioValue, 0, 0);
        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = 'low';

        const candidateColumns = getResponsiveColumns(cssWidth);
        const maxByHeight = Math.max(1, Math.floor(cssHeight / 130));
        const finalColumns = Math.min(candidateColumns, maxByHeight);
        const finalRows = getResponsiveRows(cssWidth, cssHeight, finalColumns);
        lastGeometry = computeGeometry(cssWidth, cssHeight, finalColumns, finalRows);
        updateGridCache(lastGeometry);
        drawGrid(context, lastGeometry, interactionState);
      }

      function updateCanvasAspectFromUI() {
        if (!sizeGroup) return;
        const selectedButton = sizeGroup.querySelector('[data-selected="true"]') || sizeGroup.querySelector('.btn.btn-primary');
        const value = selectedButton ? selectedButton.getAttribute('value') : 'landscape';
        // Compute fixed aspect dimensions based on stage width and 80vh cap
        const stage = canvas.parentElement;
        const stageRect = stage.getBoundingClientRect();
        const topControls = document.getElementById('top-controls');
        // Toolbar is fixed; compute available height under it
        const toolbarRect = topControls ? topControls.getBoundingClientRect() : { bottom: 48 };
        // Canvas must be 32px below toolbar bottom
        const spacer = 32;
        const availableStageHeight = Math.max(0, window.innerHeight - (toolbarRect.bottom || 48) - spacer);
        // Hard cap at 80vh by spec
        const eightyVh = window.innerHeight * 0.8;
        const maxHeight = Math.min(eightyVh, availableStageHeight || eightyVh);
        const maxWidth = stageRect.width * 0.98; // small inset to avoid overflow

        let targetWidth = maxWidth;
        let targetHeight = maxHeight;
        if (value === 'square') {
          const size = Math.min(maxWidth, maxHeight);
          targetWidth = size;
          targetHeight = size;
        } else if (value === 'portrait') {
          // 19.5:9 (modern phone portrait)
          const portraitW = 9;
          const portraitH = 19.5;
          // widthByHeight: given maxHeight, the width that fits the ratio
          const widthByHeight = maxHeight * (portraitW / portraitH);
          // heightByWidth: given maxWidth, the height that fits the ratio
          const heightByWidth = maxWidth * (portraitH / portraitW);
          if (widthByHeight <= maxWidth) {
            targetWidth = widthByHeight;
            targetHeight = maxHeight;
          } else {
            targetWidth = maxWidth;
            targetHeight = heightByWidth;
          }
        } else {
          // landscape 16:9
          const heightByWidth = maxWidth * (9 / 16);
          const widthByHeight = maxHeight * (16 / 9);
          if (heightByWidth <= maxHeight) {
            targetWidth = maxWidth;
            targetHeight = heightByWidth;
          } else {
            targetWidth = widthByHeight;
            targetHeight = maxHeight;
          }
        }

        canvas.style.width = `${Math.floor(targetWidth)}px`;
        canvas.style.height = `${Math.floor(targetHeight)}px`;
        // Match toolbar width exactly to canvas width and position canvas 32px below
        if (topControls) {
          topControls.style.width = `${Math.floor(targetWidth)}px`;
        }
        canvas.style.marginTop = `${spacer}`.concat('px');
        // Redraw with new size
        requestAnimationFrame(() => {
          resizeCanvasAndDraw();
          positionTopControlsToCanvas();
        });
      }

      function positionTopControlsToCanvas() {
        const topControls = document.getElementById('top-controls');
        const gridToggle = document.getElementById('grid-toggle-floating');
        if (!topControls) return;
        const rect = canvas.getBoundingClientRect();
        topControls.style.left = `${rect.left + rect.width / 2}px`;
        topControls.style.transform = 'translateX(-50%)';
        topControls.style.width = `${Math.floor(rect.width)}px`;
        if (gridToggle) {
          const bottomOffset = 12; // px below canvas
          const leftOffset = 12; // px from left edge of canvas
          gridToggle.style.left = `${rect.left + leftOffset}px`;
          gridToggle.style.top = `${rect.bottom + bottomOffset}px`;
        }
      }

      function computeGeometry(width, height, cols, rws) {
        const columnWidth = width / cols;
        const rowHeight = height / rws;
        const verticals = [];
        const horizontals = [];
        for (let i = 1; i < cols; i += 1) verticals.push(i * columnWidth);
        for (let j = 1; j < rws; j += 1) horizontals.push(j * rowHeight);
        return { width, height, cols, rows: rws, colWidth: columnWidth, rowHeight, verticals, horizontals };
      }

      // Build/update cached grid background
      function updateGridCache(geom) {
        const { width, height, cols, rows: rws, colWidth, rowHeight, verticals, horizontals } = geom;
        const signature = `${Math.round(width)}x${Math.round(height)}-${cols}x${rws}`;
        if (signature === lastCacheSignature && gridCacheCanvas) return;
        lastCacheSignature = signature;
        if (!gridCacheCanvas) {
          gridCacheCanvas = document.createElement('canvas');
          gridCacheCtx = gridCacheCanvas.getContext('2d', { alpha: true });
        }
        gridCacheCanvas.width = Math.max(1, Math.round(width));
        gridCacheCanvas.height = Math.max(1, Math.round(height));
        const ctx = gridCacheCtx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'low';

        // Pre-render cell fills
        const totalCells = cols * rws;
        for (let rowIndex = 0; rowIndex < rws; rowIndex += 1) {
          for (let colIndex = 0; colIndex < cols; colIndex += 1) {
            const cellIndex = rowIndex * cols + colIndex;
            const hue = (cellIndex * 360) / totalCells;
            ctx.fillStyle = `hsl(${hue} 65% 50% / 0.9)`;
            const x = colIndex * colWidth;
            const y = rowIndex * rowHeight;
            ctx.fillRect(x, y, colWidth, rowHeight);
          }
        }
        // Grid lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.lineWidth = 1.25;
        ctx.beginPath();
        for (let i = 0; i < verticals.length; i += 1) {
          const x = verticals[i];
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
        }
        for (let j = 0; j < horizontals.length; j += 1) {
          const y = horizontals[j];
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
        }
        ctx.stroke();

        // Produce an ImageBitmap when supported for faster drawImage
        if (window.createImageBitmap) {
          if (gridCacheBitmap && gridCacheBitmap.close) {
            try { gridCacheBitmap.close(); } catch (_) {}
            gridCacheBitmap = null;
          }
          createImageBitmap(gridCacheCanvas).then((bmp) => {
            gridCacheBitmap = bmp;
            scheduleRedraw();
          }).catch(() => { gridCacheBitmap = null; });
        }
      }

      function drawGrid(context, geom, _state) {
        const { width, height } = geom;
        context.clearRect(0, 0, width, height);
        // Default white background
        context.save();
        context.fillStyle = '#ffffff';
        context.fillRect(0, 0, width, height);
        context.restore();
        if (isGridEnabled) {
          if (gridCacheBitmap) {
            context.drawImage(gridCacheBitmap, 0, 0, width, height);
          } else if (gridCacheCanvas) {
            context.drawImage(gridCacheCanvas, 0, 0, width, height);
          }
        }
        renderAssets(context);
        drawMarquee(context);
        context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        context.lineWidth = 1.25;
        context.strokeRect(0, 0, width, height);
      }

      function strokeLine(ctx, x1, y1, x2, y2, style) {
        const { strokeStyle, lineWidth, shadowColor = 'transparent', shadowBlur = 0 } = style;
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = shadowBlur;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        // Reset shadow to avoid leaking into subsequent strokes
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      }

      // No hover/selection styling anymore

      // Hover/selection detection removed

      function redraw() {
        if (!lastGeometry) return;
        const ctx = canvas.getContext('2d');
        drawGrid(ctx, lastGeometry, interactionState);
      }

      // Removed hover/selection interaction handlers

      window.addEventListener('resize', () => { updateCanvasAspectFromUI(); positionTopControlsToCanvas(); });
      window.addEventListener('scroll', () => { positionTopControlsToCanvas(); }, { passive: true });
      if (window.ResizeObserver) {
        const observer = new ResizeObserver(() => resizeCanvasAndDraw());
        observer.observe(canvas);
      }
      if (sizeGroup) {
        sizeGroup.addEventListener('click', (e) => {
          const path = e.composedPath && e.composedPath();
          const btn = (path || []).find((n) => n && n.tagName && n.tagName.toLowerCase && n.tagName.toLowerCase() === 'button');
          if (btn && btn.closest('#canvas-size-group')) {
            sizeGroup.querySelectorAll('button').forEach((b) => {
              b.classList.remove('btn-primary');
              b.dataset.selected = 'false';
              b.setAttribute('aria-pressed', 'false');
            });
            btn.classList.add('btn-primary');
            btn.dataset.selected = 'true';
            btn.setAttribute('aria-pressed', 'true');
            updateCanvasAspectFromUI();
          }
        });
      }
      updateCanvasAspectFromUI();
      resizeCanvasAndDraw();
      positionTopControlsToCanvas();

      // Grid toggle button
      const gridToggleBtn = document.getElementById('toggle-grid-btn');
      if (gridToggleBtn) {
        gridToggleBtn.addEventListener('click', () => {
          isGridEnabled = !isGridEnabled;
          gridToggleBtn.classList.toggle('active', isGridEnabled);
          gridToggleBtn.setAttribute('aria-pressed', String(isGridEnabled));
          scheduleRedraw();
        });
      }

      // Add text overlay logic
      const openAddText = document.getElementById('open-add-text');
      const openGenerateText = document.getElementById('open-generate-text');
      const addTextOverlay = document.getElementById('add-text-overlay');
      const addTextInput = document.getElementById('add-text-input');
      const generateTextInput = document.getElementById('generate-text-input');
      const addTextCancel = document.getElementById('add-text-cancel');
      const addTextConfirm = document.getElementById('add-text-confirm');
      const generateTextBtn = document.getElementById('generate-text');
      const generatePreview = document.getElementById('generate-preview');
      function openTextOverlay() {
        addTextOverlay.classList.add('show');
        setTimeout(() => { addTextInput.focus(); }, 0);
      }
      function closeTextOverlay() {
        addTextOverlay.classList.remove('show');
        addTextInput.value = '';
        generateTextInput.value = '';
        generatePreview.textContent = '';
        addTextConfirm.disabled = true;
        generateTextBtn.disabled = true;
      }
      function confirmAddText() {
        const text = (generatePreview.textContent.trim() || addTextInput.value.trim());
        if (!text) { addTextInput.focus(); return; }
        const rect = canvas.getBoundingClientRect();
        const x = Math.round(rect.width / 2 - 120);
        const y = Math.round(rect.height / 2);
        addTextAsset(text, x, y, { color: '#111827', font: 'bold 32px Arial' });
        closeTextOverlay();
      }
      if (openAddText) openAddText.addEventListener('click', openTextOverlay);
      if (openGenerateText) openGenerateText.addEventListener('click', openTextOverlay);
      if (addTextCancel) addTextCancel.addEventListener('click', closeTextOverlay);
      if (addTextConfirm) addTextConfirm.addEventListener('click', confirmAddText);
      addTextInput && addTextInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { confirmAddText(); e.preventDefault(); }
        if (e.key === 'Escape') { closeTextOverlay(); e.preventDefault(); }
      });
      generateTextInput && generateTextInput.addEventListener('input', () => {
        generateTextBtn.disabled = generateTextInput.value.trim().length === 0;
      });
      // Streaming generation via OpenAI Chat Completions (acts as Cursor backend). Set your key once in DevTools:
      // localStorage.setItem('OPENAI_API_KEY', 'sk-...')
      async function streamGenerateText(prompt, onChunk, onDone, onError, { maxWords = 30 } = {}) {
        const apiKey = localStorage.getItem('OPENAI_API_KEY');
        if (!apiKey) {
          onError && onError(new Error('Missing OPENAI_API_KEY in localStorage'));
          alert('Please set your OpenAI API key in localStorage as OPENAI_API_KEY');
          return;
        }
        try {
          const controller = new AbortController();
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`,
            },
            body: JSON.stringify({
              model: 'gpt-4o-mini',
              stream: true,
              messages: [
                { role: 'system', content: 'You are a helpful copywriter. Generate concise, accurate copy that follows the user prompt. Use fewer than 30 words.' },
                { role: 'user', content: `${prompt} (<= ${maxWords} words)` }
              ],
              temperature: 0.7,
              max_tokens: 120,
            }),
            signal: controller.signal,
          });
          if (!response.ok || !response.body) {
            throw new Error(`Generation failed: ${response.status}`);
          }
          const reader = response.body.getReader();
          const decoder = new TextDecoder('utf-8');
          let buffer = '';
          let accumulated = '';
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const parts = buffer.split('\n\n');
            buffer = parts.pop();
            for (const part of parts) {
              const line = part.trim();
              if (!line) continue;
              const lines = line.split('\n');
              for (const l of lines) {
                if (!l.startsWith('data:')) continue;
                const data = l.slice(5).trim();
                if (data === '[DONE]') {
                  onDone && onDone();
                  return;
                }
                try {
                  const json = JSON.parse(data);
                  const token = json.choices?.[0]?.delta?.content;
                  if (token) {
                    // Word limit enforcement
                    const tentative = accumulated + token;
                    const words = tentative.trim().split(/\s+/).filter(Boolean);
                    if (words.length >= maxWords) {
                      const limited = words.slice(0, maxWords).join(' ');
                      onChunk && onChunk(limited.slice(accumulated.length));
                      controller.abort();
                      onDone && onDone();
                      return;
                    } else {
                      accumulated = tentative;
                      onChunk && onChunk(token);
                    }
                  }
                } catch (e) {
                  // ignore malformed line
                }
              }
            }
          }
          onDone && onDone();
        } catch (err) {
          console.error(err);
          onError && onError(err);
        }
      }
      generateTextBtn && generateTextBtn.addEventListener('click', () => {
        const prompt = generateTextInput.value.trim();
        if (!prompt) return;
        generatePreview.textContent = '';
        addTextConfirm.disabled = true;
        generateTextBtn.disabled = true;
        streamGenerateText(
          prompt,
          (chunk) => {
            generatePreview.textContent += chunk;
          },
          () => {
            addTextConfirm.disabled = generatePreview.textContent.trim().length === 0;
            generateTextBtn.disabled = false;
          },
          () => {
            generateTextBtn.disabled = false;
          },
          { maxWords: 30 }
        );
      });

      // Enter triggers Generate when prompt has text
      generateTextInput && generateTextInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && generateTextInput.value.trim().length > 0) {
          e.preventDefault();
          if (!generateTextBtn.disabled) generateTextBtn.click();
        }
      });

      // ===== Assets: API and rendering =====
      function renderAssets(ctx) {
        // Draw images and videos
        for (let i = 0; i < assets.length; i += 1) {
          const item = assets[i];
          if (item.type === 'image' && item.loaded) {
            try {
              if (item.bitmap) {
                ctx.drawImage(item.bitmap, item.x, item.y, item.width, item.height);
              } else if (item.element) {
                ctx.drawImage(item.element, item.x, item.y, item.width, item.height);
              }
            } catch (_) {
              // If the source was detached, skip this frame
            }
          } else if (item.type === 'video' && item.element && item.ready) {
            try {
              ctx.drawImage(item.element, item.x, item.y, item.width, item.height);
            } catch (_) {
              // drawImage can throw if a frame isn't ready yet; skip this frame
            }
          } else if (item.type === 'text') {
            ctx.save();
            ctx.fillStyle = item.color || '#ffffff';
            ctx.font = item.font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
            drawWrappedText(ctx, item.text || '', item.x, item.y, item.maxWidth);
            ctx.restore();
          }
        }
        // Draw hover/selection outlines on top
        drawAssetOutlines(ctx);
        // If any videos are present, keep updating frames
        if (assets.some((a) => a.type === 'video')) {
          requestAnimationFrame(() => {
            const ctx2 = canvas.getContext('2d');
            drawGrid(ctx2, lastGeometry, {});
          });
        }
      }

      function drawAssetOutlines(ctx) {
        const hovered = interactionState.hoveredAssetIndex;
        const selectedSet = interactionState.selectedAssetIndices;
        // Helper to compute bounds for an asset
        function getBounds(asset) { return getAssetBoundsForCanvas(ctx, asset); }
        function strokeRectStyled(b, color, lineWidth, dash = []) {
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(dash);
          ctx.strokeRect(b.x - 1, b.y - 1, b.w + 2, b.h + 2);
          ctx.restore();
        }
        // Hover outline (if different from selected)
        if (hovered >= 0 && hovered < assets.length && !selectedSet.has(hovered)) {
          const b = getBounds(assets[hovered]);
          strokeRectStyled(b, 'rgba(55, 48, 163, 0.95)', 2, [6, 4]); // dark indigo dashed
        }
        // Selected outlines
        if (selectedSet.size > 0) {
          if (selectedSet.size === 1) {
            const only = Array.from(selectedSet)[0];
            if (only >= 0 && only < assets.length) {
              const b = getBounds(assets[only]);
              strokeRectStyled(b, 'rgba(79, 70, 229, 1)', 3); // indigo solid
              drawResizeHandles(ctx, b);
            }
          } else {
            // Multi-select: show a single bounding box around all selected assets
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const idx of selectedSet) {
              if (idx < 0 || idx >= assets.length) continue;
              const bb = getBounds(assets[idx]);
              minX = Math.min(minX, bb.x);
              minY = Math.min(minY, bb.y);
              maxX = Math.max(maxX, bb.x + bb.w);
              maxY = Math.max(maxY, bb.y + bb.h);
            }
            if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
              const b = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
              strokeRectStyled(b, 'rgba(79, 70, 229, 1)', 3); // indigo solid
              drawResizeHandles(ctx, b);
            }
          }
        }

        function drawResizeHandles(c, bounds) {
          const r = 6;
          const handles = getHandlePositions(bounds);
          for (const [key, pt] of Object.entries(handles)) {
            c.save();
            const isActive = interactionState.activeHandle === key;
            const isHover = interactionState.hoveredHandle === key;
            c.beginPath();
            c.arc(pt.x, pt.y, r, 0, Math.PI * 2);
            c.fillStyle = isActive ? 'rgba(79,70,229,1)' : (isHover ? 'rgba(99,102,241,0.9)' : 'rgba(255,255,255,0.95)');
            c.fill();
            c.lineWidth = 2;
            c.strokeStyle = 'rgba(17,24,39,0.9)';
            c.stroke();
            c.restore();
          }
        }
      }

      function getSelectionBoundsForDrawing(ctx) {
        const selectedSet = interactionState.selectedAssetIndices;
        if (selectedSet.size === 0) return null;
        function getBounds(asset) { return getAssetBoundsForCanvas(ctx, asset); }
        if (selectedSet.size === 1) {
          const only = Array.from(selectedSet)[0];
          return getBounds(assets[only]);
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const idx of selectedSet) {
          const bb = getBounds(assets[idx]);
          minX = Math.min(minX, bb.x);
          minY = Math.min(minY, bb.y);
          maxX = Math.max(maxX, bb.x + bb.w);
          maxY = Math.max(maxY, bb.y + bb.h);
        }
        if (!isFinite(minX)) return null;
        return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
      }

      function getHandlePositions(bounds) {
        const { x, y, w, h } = bounds;
        return {
          nw: { x, y },
          ne: { x: x + w, y },
          se: { x: x + w, y: y + h },
          sw: { x, y: y + h },
        };
      }

      function handleAtPoint(bounds, cx, cy) {
        const r = 8;
        const handles = getHandlePositions(bounds);
        for (const [key, pt] of Object.entries(handles)) {
          const dx = cx - pt.x;
          const dy = cy - pt.y;
          if (Math.hypot(dx, dy) <= r) return key;
        }
        return null;
      }

      function addImageAsset(src, x, y, width, height) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const asset = { type: 'image', x, y, width, height, element: null, bitmap: null, loaded: false };
        img.onload = async () => {
          try {
            if (window.createImageBitmap) {
              const bmp = await createImageBitmap(img, { resizeWidth: Math.max(1, Math.round(width)), resizeHeight: Math.max(1, Math.round(height)), resizeQuality: 'low' });
              asset.bitmap = bmp;
              // Release the HTMLImageElement reference; bitmap is retained
              asset.element = null;
            } else {
              asset.element = img;
            }
          } catch (_) {
            asset.element = img;
          } finally {
            asset.loaded = true;
            scheduleRedraw();
          }
        };
        img.onerror = () => {
          // Remove failed asset
          const idx = assets.indexOf(asset);
          if (idx >= 0) assets.splice(idx, 1);
        };
        img.src = src;
        assets.push(asset);
        return asset;
      }

      function addImageAssetFromElement(imgEl, x, y, width, height) {
        // Fit inside canvas if larger
        const fitted = fitRectToCanvas(width, height);
        const asset = { type: 'image', x, y, width: fitted.width, height: fitted.height, element: imgEl, bitmap: null, loaded: true };
        clampAssetWithinCanvas(asset);
        assets.push(asset);
        scheduleRedraw();
        if (window.createImageBitmap) {
          createImageBitmap(imgEl, { resizeWidth: Math.max(1, Math.round(asset.width)), resizeHeight: Math.max(1, Math.round(asset.height)), resizeQuality: 'low' })
            .then((bmp) => {
              asset.bitmap = bmp;
              asset.element = null;
              scheduleRedraw();
            })
            .catch(() => {
              // keep element fallback
            });
        }
        return asset;
      }

      function addVideoAsset(src, x, y, width, height, { muted = true, loop = true, autoplay = true } = {}) {
        // Fit inside canvas if larger
        const fitted = fitRectToCanvas(width, height);
        const video = document.createElement('video');
        video.crossOrigin = 'anonymous';
        video.muted = muted;
        video.loop = loop;
        video.playsInline = true;
        const asset = { type: 'video', x, y, width: fitted.width, height: fitted.height, element: video, ready: false };
        clampAssetWithinCanvas(asset);
        video.addEventListener('loadeddata', () => {
          asset.ready = true;
          scheduleRedraw();
          if (video.requestVideoFrameCallback) {
            const tick = () => {
              if (!asset.ready) return;
              scheduleRedraw();
              video.requestVideoFrameCallback(() => tick());
            };
            video.requestVideoFrameCallback(() => tick());
          }
        });
        video.src = src;
        if (autoplay) {
          video.play().catch(() => {});
        }
        assets.push(asset);
        return asset;
      }

      function addTextAsset(text, x, y, options = {}) {
        const { width: cw } = getCanvasDimensions();
        const maxWidth = Math.max(120, Math.round(cw - 16));
        const asset = {
          type: 'text',
          x,
          y,
          text,
          color: options.color || '#ffffff',
          font: options.font || '24px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
          maxWidth: options.maxWidth || maxWidth,
        };
        clampAssetWithinCanvas(asset);
        assets.push(asset);
        const ctx = canvas.getContext('2d');
        drawGrid(ctx, lastGeometry, {});
        return asset;
      }

      function scaleFontPx(fontString, factor) {
        if (!fontString || typeof fontString !== 'string') return fontString;
        return fontString.replace(/(\d+(?:\.\d+)?)px/g, (m, num) => `${Math.max(1, Math.round(parseFloat(num) * factor))}px`);
      }

      function parseFontPx(fontString) {
        if (!fontString) return null;
        const m = String(fontString).match(/(\d+(?:\.\d+)?)px/);
        return m ? parseFloat(m[1]) : null;
      }

      function drawWrappedText(ctx, text, x, y, maxWidth) {
        const { width: cw } = getCanvasDimensions();
        const limit = Math.max(120, Math.min(maxWidth || cw - 16, cw - 16));
        const words = String(text || '').split(/\s+/);
        const lineHeight = Math.round((parseFontPx(ctx.font) || 16) * 1.2);
        let line = '';
        let cursorY = y;
        for (let i = 0; i < words.length; i += 1) {
          const test = line ? line + ' ' + words[i] : words[i];
          const w = ctx.measureText(test).width;
          if (w > limit && line) {
            ctx.fillText(line, x, cursorY);
            line = words[i];
            cursorY += lineHeight;
          } else {
            line = test;
          }
        }
        if (line) ctx.fillText(line, x, cursorY);
      }

      function measureWrappedText(ctx, text, maxWidth) {
        const { width: cw } = getCanvasDimensions();
        const limit = Math.max(120, Math.min(maxWidth || cw - 16, cw - 16));
        const words = String(text || '').split(/\s+/);
        const lineHeight = Math.round((parseFontPx(ctx.font) || 16) * 1.2);
        let line = '';
        let maxLineWidth = 0;
        let lines = 0;
        for (let i = 0; i < words.length; i += 1) {
          const test = line ? line + ' ' + words[i] : words[i];
          const w = ctx.measureText(test).width;
          if (w > limit && line) {
            maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
            lines += 1;
            line = words[i];
          } else {
            line = test;
          }
        }
        if (line) {
          maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
          lines += 1;
        }
        return { width: Math.min(limit, Math.round(maxLineWidth)), lines, height: Math.max(lineHeight, lines * lineHeight), lineHeight };
      }

      function getAssetBoundsForCanvas(ctx, asset) {
        if (asset.type === 'text') {
          ctx.save();
          ctx.font = asset.font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          const m = measureWrappedText(ctx, asset.text || '', asset.maxWidth);
          ctx.restore();
          // top-left box; y is baseline of first line; approximate top by one line height
          return { x: asset.x, y: asset.y - m.lineHeight + 4, w: m.width, h: m.height };
        }
        return { x: asset.x, y: asset.y, w: asset.width, h: asset.height };
      }

      // Build wrapped lines array (approximate; matches drawWrappedText logic)
      function wrapTextLines(ctx, text, maxWidth) {
        const { width: cw } = getCanvasDimensions();
        const limit = Math.max(120, Math.min(maxWidth || cw - 16, cw - 16));
        const tokens = String(text || '').split(/\s+/);
        const lines = [];
        let line = '';
        for (let i = 0; i < tokens.length; i += 1) {
          const word = tokens[i];
          const test = line ? line + ' ' + word : word;
          const w = ctx.measureText(test).width;
          if (w > limit && line) {
            lines.push(line);
            line = word;
          } else {
            line = test;
          }
        }
        if (line) lines.push(line);
        const lineHeight = Math.round((parseFontPx(ctx.font) || 16) * 1.2);
        return { lines, lineHeight, maxWidth: limit };
      }

      function computeCaretIndexAtPoint(ctx, text, font, maxWidth, clickX, clickY) {
        ctx.save();
        ctx.font = font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        const { lines, lineHeight } = wrapTextLines(ctx, text, maxWidth);
        ctx.restore();
        const lineIdx = Math.max(0, Math.min(lines.length - 1, Math.floor(clickY / lineHeight)));
        const beforeChars = lines.slice(0, lineIdx).reduce((n, s) => n + s.length + 1, 0); // +1 for implied space/newline
        const lineText = lines[lineIdx] || '';
        let posInLine = lineText.length;
        let acc = '';
        for (let i = 0; i <= lineText.length; i += 1) {
          acc = lineText.slice(0, i);
          const w = ctx.measureText(acc).width;
          if (w >= clickX) { posInLine = i; break; }
        }
        return Math.max(0, beforeChars + posInLine);
      }

      function clearAssets() {
        assets.splice(0, assets.length);
        const ctx = canvas.getContext('2d');
        drawGrid(ctx, lastGeometry, {});
      }

      // Expose a small API for programmatic placement with pixel precision
      window.CanvasAPI = {
        addImageAsset,
        addVideoAsset,
        addTextAsset,
        clearAssets,
        get assets() { return assets; },
      };

      // Optional: clicking images in the Content panel places them centered in the canvas
      const contentPanel = document.querySelector('.content-images');
      if (contentPanel) {
        // Click to add (kept) – supports image, text, video
        let suppressClickOnce = false;
        contentPanel.addEventListener('click', (e) => {
          if (suppressClickOnce) { suppressClickOnce = false; return; }
          const target = e.target;
          const assetEl = target && target.closest ? target.closest('[data-asset-type]') : null;
          const type = assetEl ? assetEl.dataset.assetType : null;
          if (!type || isDragging) return;
          const rect = canvas.getBoundingClientRect();
          if (type === 'image') {
            const placeW = Math.min(rect.width * 0.4, 360);
            const ratio = assetEl.naturalWidth && assetEl.naturalHeight ? assetEl.naturalHeight / assetEl.naturalWidth : (320 / 480);
            const placeH = placeW * ratio;
            const x = Math.round((rect.width - placeW) / 2);
            const y = Math.round((rect.height - placeH) / 2);
            addImageAssetFromElement(assetEl, x, y, Math.round(placeW), Math.round(placeH));
          } else if (type === 'text') {
            const x = Math.round(rect.width / 2 - 120);
            const y = Math.round(rect.height / 2);
            addTextAsset(assetEl.dataset.text || assetEl.textContent || 'Text', x, y, { color: assetEl.dataset.color, font: assetEl.dataset.font });
          } else if (type === 'video') {
            const placeW = Math.min(rect.width * 0.5, 420);
            const placeH = Math.round(placeW * (9 / 16));
            const x = Math.round((rect.width - placeW) / 2);
            const y = Math.round((rect.height - placeH) / 2);
            addVideoAsset(assetEl.dataset.src, x, y, Math.round(placeW), Math.round(placeH));
          }
        });

        // Drag & Drop support
        let dragGhost = null;
        let isDragging = false;
        let dragSourceEl = null;
        let didDragMove = false;

        function createGhost(el) {
          const type = el.dataset.assetType;
          let g;
          if (type === 'image') {
            g = el.cloneNode(false);
          } else if (type === 'text') {
            g = document.createElement('div');
            g.textContent = el.dataset.text || el.textContent || 'Text';
            g.style.padding = '6px 10px';
            g.style.background = 'rgba(15, 23, 42, 0.9)';
            g.style.color = '#fff';
            g.style.font = el.dataset.font || 'bold 24px Arial';
            g.style.borderRadius = '6px';
            g.style.border = '1px solid rgba(255,255,255,0.5)';
          } else if (type === 'video') {
            g = document.createElement('div');
            g.textContent = 'Video';
            g.style.padding = '6px 10px';
            g.style.background = 'rgba(15, 23, 42, 0.9)';
            g.style.color = '#fff';
            g.style.font = '600 14px system-ui';
            g.style.borderRadius = '6px';
            g.style.border = '1px solid rgba(255,255,255,0.5)';
          }
          g.style.position = 'fixed';
          g.style.pointerEvents = 'none';
          g.style.width = '160px';
          g.style.height = 'auto';
          g.style.opacity = '0.9';
          g.style.transform = 'translate(-50%, -50%) scale(1)';
          g.style.zIndex = '9999';
          document.body.appendChild(g);
          return g;
        }

        contentPanel.addEventListener('mousedown', (e) => {
          const target = e.target;
          const assetEl = target && target.closest ? target.closest('[data-asset-type]') : null;
          if (!assetEl) return;
          // Prevent native browser drag behavior that conflicts with our DnD
          e.preventDefault();
          isDragging = true;
          didDragMove = false;
          dragSourceEl = assetEl;
          if (dragGhost && dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
          dragGhost = createGhost(assetEl);
          dragGhost.style.display = 'block';
          dragGhost.style.opacity = '0.9';
          document.body.classList.add('is-dragging-asset');
          canvas.classList.add('drag-target');
          moveGhost(e.clientX, e.clientY);
        });

        window.addEventListener('mousemove', (e) => {
          if (isDragging) { didDragMove = true; moveGhost(e.clientX, e.clientY); }
        });

        function moveGhost(clientX, clientY) {
          if (!dragGhost) return;
          dragGhost.style.left = `${clientX}px`;
          dragGhost.style.top = `${clientY}px`;
        }

        window.addEventListener('mouseup', (e) => {
          if (!isDragging) return;
          isDragging = false;
          document.body.classList.remove('is-dragging-asset');
          canvas.classList.remove('drag-target');

          const drop = isPointInCanvas(e.clientX, e.clientY);
          if (dragSourceEl && didDragMove && drop) {
            const rect = canvas.getBoundingClientRect();
            const type = dragSourceEl.dataset.assetType;
            if (type === 'image') {
              let placeW = Math.min(rect.width * 0.4, 360);
              const ratio = (dragSourceEl.naturalHeight && dragSourceEl.naturalWidth) ? (dragSourceEl.naturalHeight / dragSourceEl.naturalWidth) : (320 / 480);
              placeW = Math.round(placeW * 0.9);
              const placeH = Math.round(placeW * ratio);
              const x = Math.round(e.clientX - rect.left - placeW / 2);
              const y = Math.round(e.clientY - rect.top - placeH / 2);
              addImageAssetFromElement(dragSourceEl, x, y, Math.round(placeW), Math.round(placeH));
            } else if (type === 'text') {
              const x = Math.round(e.clientX - rect.left - 60);
              const y = Math.round(e.clientY - rect.top);
              const originalFont = dragSourceEl.dataset.font || dragSourceEl.style.font || '';
              const scaledFont = scaleFontPx(originalFont, 0.9);
              addTextAsset(dragSourceEl.dataset.text || dragSourceEl.textContent || 'Text', x, y, { color: dragSourceEl.dataset.color, font: scaledFont });
            } else if (type === 'video') {
              let placeW = Math.min(rect.width * 0.5, 420);
              placeW = Math.round(placeW * 0.9);
              const placeH = Math.round(placeW * (9 / 16));
              const x = Math.round(e.clientX - rect.left - placeW / 2);
              const y = Math.round(e.clientY - rect.top - placeH / 2);
              addVideoAsset(dragSourceEl.dataset.src, x, y, Math.round(placeW), Math.round(placeH));
            }
            suppressClickOnce = true; // prevent duplicate centered add
          }
          dragSourceEl = null;
          if (dragGhost && dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
          dragGhost = null;
        });

        // Cancel drag with ESC
        window.addEventListener('keydown', (e) => {
          if (e.key !== 'Escape') return;
          if (!isDragging) return;
          isDragging = false;
          dragSourceEl = null;
          document.body.classList.remove('is-dragging-asset');
          canvas.classList.remove('drag-target');
          if (dragGhost && dragGhost.parentNode) dragGhost.parentNode.removeChild(dragGhost);
          dragGhost = null;
        });
      }

      function isPointInCanvas(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
      }

      // ===== Asset hover/selection on canvas =====
      function findAssetAtCanvasPoint(clientX, clientY) {
        if (!lastGeometry) return -1;
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const ctx = canvas.getContext('2d');
        // Search from topmost to bottom
        for (let i = assets.length - 1; i >= 0; i -= 1) {
          const a = assets[i];
          const b = getAssetBoundsForCanvas(ctx, a);
          if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) return i;
        }
        return -1;
      }

      canvas.addEventListener('mousemove', (e) => {
        // Hover detection only when not moving assets
        if (!interactionState.isMovingSelected && !interactionState.isResizingSelected) {
          const idx = findAssetAtCanvasPoint(e.clientX, e.clientY);
          if (idx !== interactionState.hoveredAssetIndex) {
            interactionState.hoveredAssetIndex = idx;
            canvas.style.cursor = idx >= 0 ? 'pointer' : 'default';
            scheduleRedraw();
          }
          // Handle hover
          if (interactionState.selectedAssetIndices.size > 0) {
            const rect = canvas.getBoundingClientRect();
            const ctx = canvas.getContext('2d');
            const selBounds = getSelectionBoundsForDrawing(ctx);
            if (selBounds) {
              const cx = e.clientX - rect.left;
              const cy = e.clientY - rect.top;
              const h = handleAtPoint(selBounds, cx, cy);
              if (h !== interactionState.hoveredHandle) {
                interactionState.hoveredHandle = h;
                if (h === 'nw' || h === 'se') canvas.style.cursor = 'nwse-resize';
                else if (h === 'ne' || h === 'sw') canvas.style.cursor = 'nesw-resize';
                else canvas.style.cursor = idx >= 0 ? 'pointer' : 'default';
                scheduleRedraw();
              }
            }
          }
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (interactionState.hoveredAssetIndex !== -1) {
          interactionState.hoveredAssetIndex = -1;
          canvas.style.cursor = 'default';
          scheduleRedraw();
        }
      });

      canvas.addEventListener('mousedown', (e) => {
        // Ignore if sidebar drag is active
        if (document.body.classList.contains('is-dragging-asset')) return;
        const idx = findAssetAtCanvasPoint(e.clientX, e.clientY);
        // Resize priority: if a handle is hovered, start resizing selection
        const rect = canvas.getBoundingClientRect();
        const ctx = canvas.getContext('2d');
        const selBounds = getSelectionBoundsForDrawing(ctx);
        if (selBounds) {
          const cx = e.clientX - rect.left;
          const cy = e.clientY - rect.top;
          const h = handleAtPoint(selBounds, cx, cy);
          if (h) {
            interactionState.isResizingSelected = true;
            interactionState.activeHandle = h;
            interactionState.resizeStartClientX = e.clientX;
            interactionState.resizeStartClientY = e.clientY;
            interactionState.initialSelectionBounds = selBounds;
            interactionState.initialSelectedSnapshot = Array.from(interactionState.selectedAssetIndices).map(i => ({
              index: i,
              x: assets[i].x,
              y: assets[i].y,
              width: assets[i].width,
              height: assets[i].height,
              font: assets[i].font,
              type: assets[i].type,
            }));
            interactionState.hoveredHandle = h;
            canvas.style.cursor = (h === 'nw' || h === 'se') ? 'nwse-resize' : 'nesw-resize';
            e.preventDefault();
            return;
          }
        }
        const isMulti = e.shiftKey || e.metaKey || e.ctrlKey || e.altKey;
        if (idx >= 0) {
          if (isMulti) {
            if (interactionState.selectedAssetIndices.has(idx)) {
              interactionState.selectedAssetIndices.delete(idx);
            } else {
              interactionState.selectedAssetIndices.add(idx);
            }
          } else {
            // If clicking an already-selected asset while multiple are selected,
            // keep the existing multi-selection so we move the entire group.
            if (!interactionState.selectedAssetIndices.has(idx)) {
              interactionState.selectedAssetIndices.clear();
              interactionState.selectedAssetIndices.add(idx);
            }
          }
          // Begin move for selected assets
          interactionState.isMovingSelected = true;
          interactionState.lastMoveClientX = e.clientX;
          interactionState.lastMoveClientY = e.clientY;
          canvas.style.cursor = 'grabbing';
          scheduleRedraw();
          e.preventDefault();
        } else {
          // Clicked empty space: clear selection unless multi key held
          if (!isMulti && interactionState.selectedAssetIndices.size) {
            interactionState.selectedAssetIndices.clear();
            scheduleRedraw();
          }
          // Start marquee selection
          const rect = canvas.getBoundingClientRect();
          interactionState.isMarqueeSelecting = true;
          interactionState.marqueeStartCX = e.clientX - rect.left;
          interactionState.marqueeStartCY = e.clientY - rect.top;
          interactionState.marqueeEndCX = interactionState.marqueeStartCX;
          interactionState.marqueeEndCY = interactionState.marqueeStartCY;
          interactionState.marqueeAdditive = isMulti;
          canvas.style.cursor = 'crosshair';
          e.preventDefault();
        }
      });

      // Move selected assets with pointer
      window.addEventListener('mousemove', (e) => {
        if (interactionState.isResizingSelected) {
          const start = interactionState.initialSelectionBounds;
          if (!start) return;
          const cx = e.clientX;
          const cy = e.clientY;
          const dx = cx - interactionState.resizeStartClientX;
          const dy = cy - interactionState.resizeStartClientY;
          // Compute scale based on active handle movement, uniform scaling to preserve aspect
          let scaleX = 1, scaleY = 1;
          if (interactionState.activeHandle === 'se') { scaleX = (start.w + dx) / start.w; scaleY = (start.h + dy) / start.h; }
          if (interactionState.activeHandle === 'ne') { scaleX = (start.w + dx) / start.w; scaleY = (start.h - dy) / start.h; }
          if (interactionState.activeHandle === 'sw') { scaleX = (start.w - dx) / start.w; scaleY = (start.h + dy) / start.h; }
          if (interactionState.activeHandle === 'nw') { scaleX = (start.w - dx) / start.w; scaleY = (start.h - dy) / start.h; }
          let s = Math.max(0.05, Math.max(scaleX, scaleY));
          // Apply scale relative to top-left of selection (start.x, start.y)
          const { width: cw, height: ch } = getCanvasDimensions();
          for (const snap of interactionState.initialSelectedSnapshot || []) {
            const a = assets[snap.index];
            if (!a) continue;
            const relX = snap.x - start.x;
            const relY = snap.y - start.y;
            if (snap.type === 'text') {
              a.x = Math.round(start.x + relX * s);
              a.y = Math.round(start.y + relY * s);
              a.font = scaleFontPx(snap.font || '16px Arial', s);
              a.maxWidth = Math.min(a.maxWidth || cw - 16, cw - 16);
            } else {
              a.x = Math.round(start.x + relX * s);
              a.y = Math.round(start.y + relY * s);
              a.width = Math.max(8, Math.round((snap.width || 0) * s));
              a.height = Math.max(8, Math.round((snap.height || 0) * s));
              // Constrain within canvas during preview
              a.width = Math.min(a.width, cw - 1);
              a.height = Math.min(a.height, ch - 1);
            }
          }
          scheduleRedraw();
        } else if (interactionState.isMovingSelected) {
          const dx = e.clientX - interactionState.lastMoveClientX;
          const dy = e.clientY - interactionState.lastMoveClientY;
          if (dx === 0 && dy === 0) return;
          interactionState.lastMoveClientX = e.clientX;
          interactionState.lastMoveClientY = e.clientY;
        for (const idx of interactionState.selectedAssetIndices) {
            const a = assets[idx];
            if (!a) continue;
          a.x = Math.round(a.x + dx);
          a.y = Math.round(a.y + dy);
          clampAssetWithinCanvas(a);
          }
          scheduleRedraw();
        } else if (interactionState.isMarqueeSelecting) {
          const rect = canvas.getBoundingClientRect();
          interactionState.marqueeEndCX = e.clientX - rect.left;
          interactionState.marqueeEndCY = e.clientY - rect.top;
          scheduleRedraw();
        }
      });

      window.addEventListener('mouseup', () => {
        if (interactionState.isResizingSelected) {
          interactionState.isResizingSelected = false;
          interactionState.activeHandle = null;
          canvas.style.cursor = 'default';
          // Final clamp into canvas after resize ends
          for (const idx of interactionState.selectedAssetIndices) {
            const a = assets[idx];
            if (!a) continue;
            clampAssetWithinCanvas(a);
          }
        }
        if (interactionState.isMovingSelected) {
          interactionState.isMovingSelected = false;
          canvas.style.cursor = 'default';
        }
        if (interactionState.isMarqueeSelecting) {
          finalizeMarqueeSelection();
        }
      });

      // ===== In-canvas text editing =====
      const textEditor = document.getElementById('canvas-text-editor');
      let editingAssetIndex = -1;

      function endTextEdit(commit = true) {
        if (editingAssetIndex >= 0) {
          const a = assets[editingAssetIndex];
          if (a && commit) {
            a.text = textEditor.value;
          }
        }
        editingAssetIndex = -1;
        textEditor.style.display = 'none';
        scheduleRedraw();
      }

      function beginTextEdit(targetIndex, clientX, clientY) {
        const a = assets[targetIndex];
        if (!a || a.type !== 'text') return;
        editingAssetIndex = targetIndex;
        // Size and position editor
        const ctx = canvas.getContext('2d');
        ctx.font = a.font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        const bounds = getAssetBoundsForCanvas(ctx, a);
        const rect = canvas.getBoundingClientRect();
        const left = rect.left + bounds.x - 4;
        const top = rect.top + bounds.y - 2;
        textEditor.style.left = `${Math.round(left)}px`;
        textEditor.style.top = `${Math.round(top)}px`;
        textEditor.style.width = `${Math.max(80, Math.round(Math.min(bounds.w + 8, rect.width - bounds.x - 8)))}px`;
        textEditor.style.height = `${Math.max(24, Math.round(bounds.h + 6))}px`;
        textEditor.style.font = a.font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        textEditor.value = a.text || '';
        textEditor.style.display = 'block';
        textEditor.focus();
        // Place caret at click position in wrapped layout
        const caretX = clientX - (rect.left + bounds.x);
        const caretY = clientY - (rect.top + bounds.y);
        const caretIndex = computeCaretIndexAtPoint(ctx, a.text || '', a.font, a.maxWidth, caretX, caretY);
        textEditor.setSelectionRange(caretIndex, caretIndex);
      }

      canvas.addEventListener('dblclick', (e) => {
        const idx = findAssetAtCanvasPoint(e.clientX, e.clientY);
        if (idx >= 0 && assets[idx].type === 'text') {
          if (!interactionState.selectedAssetIndices.has(idx)) {
            interactionState.selectedAssetIndices.clear();
            interactionState.selectedAssetIndices.add(idx);
            scheduleRedraw();
          }
          // cancel any in-progress move/resize
          interactionState.isMovingSelected = false;
          interactionState.isResizingSelected = false;
          beginTextEdit(idx, e.clientX, e.clientY);
          e.preventDefault();
        }
      });

      // Enter (without Shift) commits; Esc cancels
      textEditor.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); endTextEdit(true); }
        if (e.key === 'Escape') { e.preventDefault(); endTextEdit(false); }
      });
      // Clicking outside commits
      window.addEventListener('mousedown', (e) => {
        if (editingAssetIndex >= 0 && e.target !== textEditor) {
          endTextEdit(true);
        }
      }, true);

      function drawMarquee(ctx) {
        if (!interactionState.isMarqueeSelecting) return;
        const x1 = interactionState.marqueeStartCX;
        const y1 = interactionState.marqueeStartCY;
        const x2 = interactionState.marqueeEndCX;
        const y2 = interactionState.marqueeEndCY;
        const x = Math.min(x1, x2);
        const y = Math.min(y1, y2);
        const w = Math.abs(x2 - x1);
        const h = Math.abs(y2 - y1);
        ctx.save();
        ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
        ctx.strokeStyle = 'rgba(99, 102, 241, 0.9)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);
        ctx.restore();
      }

      function rectsIntersect(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function finalizeMarqueeSelection() {
        const x1 = interactionState.marqueeStartCX;
        const y1 = interactionState.marqueeStartCY;
        const x2 = interactionState.marqueeEndCX;
        const y2 = interactionState.marqueeEndCY;
        const x = Math.min(x1, x2);
        const y = Math.min(y1, y2);
        const w = Math.abs(x2 - x1);
        const h = Math.abs(y2 - y1);
        const box = { x, y, w, h };
        const ctx = canvas.getContext('2d');
        const newlySelected = new Set();
        for (let i = 0; i < assets.length; i += 1) {
          const a = assets[i];
          let b;
          if (a.type === 'text') {
            ctx.save();
            ctx.font = a.font || '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
            const width = Math.max(1, Math.round(ctx.measureText(a.text || '').width));
            const match = (a.font || '').match(/(\d+(?:\.\d+)?)px/);
            const fontPx = match ? parseFloat(match[1]) : 16;
            const height = Math.max(1, Math.round(fontPx * 1.2));
            ctx.restore();
            b = { x: a.x, y: a.y - height + 4, w: width, h: height };
          } else {
            b = { x: a.x, y: a.y, w: a.width, h: a.height };
          }
          if (rectsIntersect(box, b)) newlySelected.add(i);
        }
        if (!interactionState.marqueeAdditive) interactionState.selectedAssetIndices.clear();
        for (const i of newlySelected) interactionState.selectedAssetIndices.add(i);
        interactionState.isMarqueeSelecting = false;
        canvas.style.cursor = 'default';
        scheduleRedraw();
      }

      // Keyboard nudge for selected assets
      window.addEventListener('keydown', (e) => {
        const arrows = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        if (!arrows.includes(e.key)) return;
        if (interactionState.selectedAssetIndices.size === 0 || document.activeElement === document.getElementById('canvas-text-editor')) return;
        const step = e.shiftKey ? 10 : (e.altKey ? 1 : 2);
        let dx = 0, dy = 0;
        if (e.key === 'ArrowLeft') dx = -step;
        if (e.key === 'ArrowRight') dx = step;
        if (e.key === 'ArrowUp') dy = -step;
        if (e.key === 'ArrowDown') dy = step;
        for (const idx of interactionState.selectedAssetIndices) {
          const a = assets[idx];
          if (!a) continue;
          a.x = Math.round(a.x + dx);
          a.y = Math.round(a.y + dy);
        }
        scheduleRedraw();
        e.preventDefault();
      });

      // Delete selected assets with Delete/Backspace
      window.addEventListener('keydown', (e) => {
        if (e.key !== 'Delete' && e.key !== 'Backspace') return;
        if (interactionState.selectedAssetIndices.size === 0) return;
        // Remove in descending order to avoid index shifts
        const toRemove = Array.from(interactionState.selectedAssetIndices).sort((a, b) => b - a);
        for (const idx of toRemove) {
          if (idx >= 0 && idx < assets.length) assets.splice(idx, 1);
        }
        interactionState.selectedAssetIndices.clear();
        interactionState.hoveredAssetIndex = -1;
        scheduleRedraw();
        e.preventDefault();
      });
    })();
  </script>
</body>
</html>
